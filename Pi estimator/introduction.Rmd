---
title: "Pi estimator"
author: "Diabb Zegpi"
date: "17-05-2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      dev = "png", fig.width = 10, fig.height = 7, dpi = 500,
                      dev.args = list(type = "cairo"))
```

This is a super smart way (though no efficient nor accurate) of estimating ![here pi][pi] using geometry. Whenever we see ![here pi again][pi], we have to think on circles, so the key is to elaborate a relationship between a circle and other geometric figure. This is ![def][pi] definition:

#### *"The ratio of a circle's circumference to its diameter."*

Imagine a circle inscribed in a square. The relationship between their areas is ![f1][formula1], so we can isolate ![pi][pi] as ![f2][formula2]. This is easy, but the problem remains on how to estimate pi from this.

<p align="center">
  <img width="200" height="200" src="https://www.varsitytutors.com/assets/vt-hotmath-legacy/hotmath_help/topics/circles-inscribed-in-squares/lesson1.gif">
</p>

Now that we have isolated ![pi][pi] the next step is figure out how to compute it. Here is when a nice idea comes to place: let's imagine that we cover the square's surface with many randomly generated points, some of them will fall within the circle. That's it! the number of points in the circle over the total number of points, times four, gives us an estimation of pi. The bigger the number of points, the better the estimation is.

Now is time to program this in R and generate some visualizations. Let's get our hands dirty. The plan is to create a function that models the above approach.

The only things we need to define our circle are the radius `r` and reference points, to draw it later. Also, we will need the user to specify a number `n` of points to sample. By default, the circle will be centered at the origin with radius 5.

```{r}
pi_estimator <- function(r = 5, n, x_coord = 0, y_coord = 0){
  # Generate random points
  x_axis <- runif(n, min = x_coord - r, max = x_coord + r)
  y_axis <- runif(n, min = y_coord - r, max = y_coord + r)
  
  # Every pair of coordinates is a point
  coordinates <- data.frame(x_axis, y_axis)
  
  # Has point fall into the circle?
  coordinates$fall_in <- ifelse(
    sqrt(coordinates$x_axis ^ 2 + coordinates$y_axis ^ 2) <= r, TRUE, FALSE)
  
  # Calculate pi estimator
  estimation <- 4 * mean(coordinates$fall_in)
  
  # Return the value and the points
  return(list(estimation = estimation, points = coordinates))
}
```

How well is the estimator performing?

```{r}
set.seed(2020)
pi_estimator(r = 7, n = 10000)$estimation
```

As the number of points increase, the estimation will be more accurate. Let's visualize this.



[pi]: https://render.githubusercontent.com/render/math?math=%24%5Cpi%24
[formula1]: https://render.githubusercontent.com/render/math?math=%24%5Cfrac%7BA_%7Bcircle%7D%7D%7BA_%7Bsquare%7D%7D%3D%20%5Cfrac%7B%5Cpi%20r%5E2%7D%7B4r%5E2%7D%24
[formula2]:https://render.githubusercontent.com/render/math?math=%244%5Cfrac%7BA_%7Bcircle%7D%7D%7BA_%7Bsquare%7D%7D%24
